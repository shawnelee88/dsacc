#include "hashsep.h"#include "fatal.h"#include <stdlib.h>#define MinTableSize (10) struct ListNode{    ElemType Element;    Position Next;};typedef Position List;/* List *TheLists will be an array of lists, allocated later *//* The lists use headers (for simplicity), *//* though this wastes space */struct HashTbl{    int TableSize;    List *TheLists;};/* Return next prime; assume N >= 10 */int NextPrime( int N){    int i;    if( N % 2 == 0 )        N++;    for( ; ; N += 2 )    {        for( i = 3; i * i <= N; i += 2 )            if( N % i == 0 )				goto ContOuter;  /* Sorry about this! */        return N;        ContOuter: ;    }}Index Hash(ElemType Key, int TableSize){      return Key % TableSize;}HashTable InitializeTable(int TableSize){    HashTable H;    int i;        if(TableSize < MinTableSize){        Error("Table size too small!");        return NULL;    }        /*allocate table*/    H = malloc(sizeof(struct HashTbl));    if(H == NULL){        FatalError("Out of space!");    }        H->TableSize = NextPrime(TableSize);        /*allocate array of lists*/    H->TheLists = (List *)malloc((H->TableSize) * sizeof(List));    if(H->TheLists == NULL){        FatalError("Our of space!");    }        /*allocate list headers*/    //H->TheLists = malloc(H->TableSize * sizeof(struct ListNode));    for(i = 0; i < H->TableSize; i++){        H->TheLists[i] = malloc(sizeof(struct ListNode));        if(H->TheLists[i] == NULL){            FatalError("Out of space!");        }else{            H->TheLists[i]->Next = NULL;        }    }        return H;}Position Find(ElemType Key, HashTable H){    Position P;    List L;    L = H->TheLists[Hash(Key, H->TableSize)];    P = L->Next;    while((P != NULL) && (P->Element != Key)){        P = P->Next;    }        return P;}void Insert(ElemType Key, HashTable H){    Position Pos, NewCell;    List L;        Pos = Find(Key, H);    if(Pos == NULL){    /*Key is not found*/        NewCell = malloc(sizeof(struct ListNode));        if(NewCell == NULL){            FatalError("Out of space!");        }else{            L = H->TheLists[Hash(Key, H->TableSize)];            NewCell->Next = L->Next;            NewCell->Element = Key;  /*probably need strcpy*/            L->Next = NewCell;        }    }}ElemType Retrieve(Position P){    return P->Element;}void DestroyTable(HashTable H){    int i;    Position P, tmp;        for(i = 0; i < H->TableSize; i++){        P = H->TheLists[i];                while(P != NULL){            tmp = P->Next;            free(P);            P = tmp;        }    }        free(H->TheLists);    free(H);}void Traverse(HashTable H){	List tmpList;	Position tmpPos;	int i;	int count = 0;	int totalCount = 0;		for(i = 0; i < H->TableSize; i++){		count = 0;		tmpList = H->TheLists[i];		if(tmpList->Next == NULL){			printf("No elements in this List!\n");		}else{			tmpPos = tmpList->Next;			while(tmpPos->Next != NULL){				printf("%d        ", tmpPos->Element);				tmpPos = tmpPos->Next;				count++;			}			printf("%d", tmpPos->Element);			count++;				}		totalCount += count;		printf("\n%d in %d th list.\n", count, i);			}	printf("Totally %d elements in this HashTable.\n", totalCount);}